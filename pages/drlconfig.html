<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <style>
        :root {
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            font-family: var(--font-family);
        }
    </style>
</head>

<body>
    <script>
        // Credit https://github.com/joeiddon/perlin/blob/master/perlin.js
        let perlin = {
            rand_vect: function () {
                let theta = Math.random() * 2 * Math.PI;
                return { x: Math.cos(theta), y: Math.sin(theta) };
            },
            dot_prod_grid: function (x, y, vx, vy) {
                let g_vect;
                let d_vect = { x: x - vx, y: y - vy };
                if (this.gradients[[vx, vy]]) {
                    g_vect = this.gradients[[vx, vy]];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[[vx, vy]] = g_vect;
                }
                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            },
            smootherstep: function (x) {
                return 6 * x ** 5 - 15 * x ** 4 + 10 * x ** 3;
            },
            interp: function (x, a, b) {
                return a + this.smootherstep(x) * (b - a);
            },
            seed: function () {
                this.gradients = {};
                this.memory = {};
            },
            get: function (x, y) {
                if (this.memory.hasOwnProperty([x, y]))
                    return this.memory[[x, y]];
                let xf = Math.floor(x);
                let yf = Math.floor(y);
                //interpolate
                let tl = this.dot_prod_grid(x, y, xf, yf);
                let tr = this.dot_prod_grid(x, y, xf + 1, yf);
                let bl = this.dot_prod_grid(x, y, xf, yf + 1);
                let br = this.dot_prod_grid(x, y, xf + 1, yf + 1);
                let xt = this.interp(x - xf, tl, tr);
                let xb = this.interp(x - xf, bl, br);
                let v = this.interp(y - yf, xt, xb);
                this.memory[[x, y]] = v;
                return v;
            },
            clearMemory: function () {
                this.memory = {};
            }
        }
    </script>
    <style>
        /* Remove focus outlines / focus box-shadows */
        input,
        textarea,
        select,
        button,
        a,
        [tabindex] {
            outline: none !important;
            box-shadow: none !important;
            -webkit-appearance: none;
            /* optional for some browsers */
        }

        /* Also catch :focus pseudo-class */
        input:focus,
        textarea:focus,
        select:focus,
        button:focus,
        a:focus,
        [tabindex]:focus {
            outline: none !important;
            box-shadow: none !important;
        }

        /* Disable text selection globally */
        html,
        body,
        * {
            -webkit-user-select: none;
            /* Chrome, Safari */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE/Edge */
            user-select: none;
            /* Standard */
        }

        body {
            margin: 0;
            background: black;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* If you still want pointer interactions to work (click/hover), don't change pointer-events */
    </style>
    <div style="width: 100vw; height: 100vh; overflow: hidden; position: fixed; top: 0; left: 0; z-index: -1;">
        <canvas id="backdrop" style="width: 100vw; height: 100vh; overflow: hidden;"></canvas>
    </div>
    <div style="width: 100vw; height: 100vh; overflow: hidden; position: fixed; top: 0; left: 0; z-index: 1;">
        <style>
            :root {
                --settings-container-margin: 5vh;
                --default-box-shadow: inset 0 0 0 5px rgb(0, 0, 0);
            }

            * {
                box-shadow: inset 0 0 0 2px rgba(255, 0, 0, 0);
            }

            .settings-container {
                width: calc(100% - 100px);
                height: 100%;
                margin: 0px auto;
            }
        </style>
        <div class="settings-container">
            <style>
                .flex-container {
                    display: flex;
                    flex-wrap: wrap;
                    align-items: center;
                    justify-content: center;
                    align-content: center;
                    gap: 10%;
                }

                .flex-container .box {
                    flex: 1 1 300px;
                    width: min-content;
                }
            </style>
            <div class="flex-container" style="width: 100%; height: 100%;">
                <div class="box">
                    <style>
                        .button-object span {
                            font-size: 50px;
                        }

                        .button-object .chevron {
                            aspect-ratio: 1/1;
                            display: block;
                            height: max-content;
                            width: max-content;
                            font-size: 60px;
                        }

                        .button-object p {
                            display: flex;
                            justify-content: center;
                        }

                        .button-object span {
                            margin: 0px 20px;
                        }
                    </style>
                    <div>

                        <script>
                            const availableModes = [
                                'solid', // Color
                                'rainbow*', // Rainbow
                                'breathe', // Breathing color
                                'bounce', // Color moving from one end to another
                                'comet', // Moving white orbs with color trails
                                'OEM*', // Northern lights
                            ]
                        </script>
                        <div class="button-object">
                            <p>
                                <style>
                                    .mode-test {
                                        color: white;
                                    }
                                </style>
                                <script>
                                    let selectedMode = 0
                                </script>
                                <span class="chevron" onclick="setMode(selectedMode - 1)"
                                    style="margin: 0; padding: 0; margin-right: auto;">
                                    <svg xmlns="http://www.w3.org/2000/svg" height="56px" viewBox="0 -960 960 960"
                                        width="48px" fill="#e8eaed">
                                        <path d="M560-240 320-480l240-240 56 56-184 184 184 184-56 56Z" />
                                    </svg>
                                </span>
                                <span class="mode-test"
                                    style="font-weight: lighter; font-size: 30px; margin: 0; padding-right: 10px; padding-top: 10px; padding-left: 10px;">
                                    Mode:
                                </span>
                                <span class="mode-test" id="mode-entry"
                                    style="font-weight: bold; font-size: 30px; margin: 0; padding-top: 10px; padding-right: 10px;">
                                </span>
                                <span class="chevron" onclick="setMode(selectedMode + 1)"
                                    style="margin: 0; padding: 0; margin-left: auto;">
                                    <svg xmlns="http://www.w3.org/2000/svg" height="56px" viewBox="0 -960 960 960"
                                        width="48px" fill="#e8eaed">
                                        <path d="M504-480 320-664l56-56 240 240-240 240-56-56 184-184Z" />
                                    </svg>
                                </span>
                            </p>
                        </div>
                        <div class="color">
                            <style>
                                .color-picker {
                                    box-shadow: var(--default-box-shadow);
                                    width: 100%;
                                    height: 60px;
                                    position: relative;
                                    margin: 16px 0px;
                                }


                                :root {
                                    --saved-color-hue: 272deg;
                                    --saved-color-saturation: 100%;
                                    --saved-color-value: 50%;
                                }

                                .color-picker-hue {
                                    background-image: linear-gradient(to right, hsl(0deg, 100%, 50%), hsl(30deg, 100%, 50%), hsl(60deg, 100%, 50%), hsl(90deg, 100%, 50%), hsl(120deg, 100%, 50%), hsl(150deg, 100%, 50%), hsl(180deg, 100%, 50%), hsl(210deg, 100%, 50%), hsl(240deg, 100%, 50%), hsl(270deg, 100%, 50%), hsl(300deg, 100%, 50%), hsl(330deg, 100%, 50%), hsl(360deg, 100%, 50%));
                                }

                                .color-picker-saturation {
                                    background-image: linear-gradient(to right, hsl(var(--saved-color-hue), 0%, var(--saved-color-value)), hsl(var(--saved-color-hue), 100%, var(--saved-color-value)));
                                }

                                .color-picker-value {
                                    background-image: linear-gradient(to right, hsl(var(--saved-color-hue), var(--saved-color-saturation), 0%), hsl(var(--saved-color-hue), var(--saved-color-saturation), 100%));
                                }

                                .color-picker-slider {
                                    position: absolute;
                                    left: 50%;
                                    height: calc(100%);
                                    width: 10px;
                                    transform: translateX(-50%);
                                    background-color: white;
                                }
                            </style>
                            <div class="color-picker color-picker-hue">
                                <div class="color-picker-slider" style="left: 75.7929%;">

                                </div>
                            </div>
                            <div class="color-picker color-picker-saturation">
                                <div class="color-picker-slider" style="left: 99%;">

                                </div>
                            </div>
                            <div class="color-picker color-picker-value">
                                <div class="color-picker-slider" style="left: 50%;">

                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="box">
                    <div>
                        <p id="mode-select"
                            style="font-weight: bold; font-size: 50px; text-align: left; transform: translateY(30%); padding: 0px 20px; width: calc(100% - 40px); margin: 0; ">
                            solid
                        </p>
                        <p class="color-select" id="color-select"
                            style="transition-duration: 0.25s; font-weight: 300; text-transform: lowercase; font-size: 100px;display: inline-block; text-align: center; padding: 0px 20px; width: calc(100% - 40px);">
                        </p>
                    </div>
                    <style>
                        .color-select {
                            position: relative;
                            z-index: -1;
                            margin: 0px auto;
                        }

                        .disabled {
                            filter: invert(1) saturate(0) contrast(0.5) brightness(0.25) blur(13px);
                            margin-top: -62px;
                        }
                    </style>
                    <script>
                        const log = (str) => {
                            window.webkit?.messageHandlers?.log.postMessage(str.toString());
                        }
                        let stateNeedsToUpdate = false;
                        let stateLastUpdatedTime = 0;
                        let stateMessage = {
                            a: 0,
                            b: `0xffffff`
                        }
                        const doStateMessage = () => {
                            if (stateNeedsToUpdate && (Date.now() - stateLastUpdatedTime) > 100) {
                                stateLastUpdatedTime = Date.now();
                                stateNeedsToUpdate = false;
                                window.webkit?.messageHandlers?.doSomething.postMessage(stateMessage);
                                console.log("Called with message", stateMessage)
                            }
                        }
                        setInterval(doStateMessage, 10)
                        const updateState = () => {
                            if (document.getElementById("color-select").textContent.trim().length <= 0) return;
                            const message = {
                                a: selectedMode,
                                b: `0x${document.getElementById("color-select").textContent}`
                            }
                            stateMessage = message;
                            stateNeedsToUpdate = true;

                        }
                        const setMode = (newMode) => {
                            if (newMode < 0)
                                newMode = availableModes.length - 1
                            if (newMode >= availableModes.length)
                                newMode = 0;
                            document.getElementById("mode-entry").textContent = `${newMode + 1} of ${availableModes.length}`
                            document.getElementById("mode-select").textContent = availableModes[newMode].includes("*") ? availableModes[newMode].substring(0, availableModes[newMode].length - 1) : availableModes[newMode]
                            selectedMode = newMode
                            document.getElementById("color-select").classList.remove("disabled")
                            if (availableModes[newMode].includes("*")) {
                                document.getElementById("color-select").classList.add("disabled")
                            }
                            updateState();
                        }
                        setMode(0)

                        // Credit https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex
                        function hslToHex(h, s, l) {
                            l /= 100;
                            const a = s * Math.min(l, 1 - l) / 100;
                            const f = n => {
                                const k = (n + h / 30) % 12;
                                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                                return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
                            };
                            return `${f(0)}${f(8)}${f(4)}`;
                        }
                        const updateColor = () => {
                            let h = window.getComputedStyle(document.body).getPropertyValue('--saved-color-hue');
                            h = parseFloat(h.substring(0, h.indexOf("deg")))
                            let s = window.getComputedStyle(document.body).getPropertyValue('--saved-color-saturation');
                            s = parseFloat(s.substring(0, s.indexOf("%")))
                            let l = window.getComputedStyle(document.body).getPropertyValue('--saved-color-value');
                            l = parseFloat(l.substring(0, l.indexOf("%")))
                            document.getElementById("color-select").textContent = `${hslToHex(h, s, l)}`
                            document.getElementById("color-select").style.backgroundColor = `#${hslToHex(h, s, l)}`
                            document.getElementById("color-select").style.textShadow = ``
                            updateState();
                        }
                        updateColor()
                        const sliders = document.getElementsByClassName("color-picker");

                        // Create shared event handlers to prevent accumulation
                        const onUp = (click) => {
                            try {
                                Array.from(sliders).forEach(slider => {
                                    slider.setAttribute("pressed", "0");
                                });
                            }
                            catch (e) {
                                log(e)
                            }
                        }

                        const onMove = (click) => {
                            try {
                                if (click.changedTouches) {
                                    for (const changedTouch of click.changedTouches) {
                                        click.clientX = changedTouch.pageX
                                        click.clientY = changedTouch.pageY
                                    }
                                }
                                Array.from(sliders).forEach(slider => {
                                    if (slider.getAttribute("pressed") == "1") {
                                        const bounds = slider.getBoundingClientRect();
                                        const percentX = Math.min(1, Math.max(0, (click.clientX - bounds.left) / (bounds.right - bounds.left)))
                                        slider.children[0].style.left = `${Math.max(Math.min(percentX * 100, 99), 1)}%`
                                        if (slider.classList.contains("color-picker-hue")) {
                                            document.documentElement.style.setProperty('--saved-color-hue', `${Math.floor(percentX * 360)}deg`);
                                        }
                                        else if (slider.classList.contains("color-picker-saturation")) {
                                            document.documentElement.style.setProperty('--saved-color-saturation', `${Math.floor(percentX * 100)}%`);
                                        }
                                        else if (slider.classList.contains("color-picker-value")) {
                                            document.documentElement.style.setProperty('--saved-color-value', `${Math.floor(percentX * 100)}%`);
                                            if (percentX > 0.5) {
                                                document.getElementById("color-select").style.color = "black"
                                            }
                                            else if (percentX <= 0.5) {
                                                document.getElementById("color-select").style.color = "white"
                                            }
                                        }
                                        updateColor()
                                    }
                                });
                            }
                            catch (e) {
                                log(e)
                            }
                        }

                        // Add shared event listeners only once
                        document.addEventListener("mouseup", onUp)
                        document.addEventListener("touchend", onUp)
                        document.addEventListener("mousemove", onMove)
                        document.addEventListener("touchmove", onMove)

                        for (let i = 0; i < sliders.length; i++) {
                            const slider = sliders[i]
                            const onDown = (click) => {
                                try {
                                    slider.setAttribute("pressed", "1")
                                }
                                catch (e) {
                                    log(e)
                                }
                            }
                            slider.setAttribute("pressed", "0");
                            slider.addEventListener("mousedown", onDown)
                            slider.addEventListener("touchstart", onDown)
                            slider.addEventListener("click", (click) => {
                                try {
                                    const bounds = slider.getBoundingClientRect();
                                    const percentX = (click.clientX - bounds.left) / (bounds.right - bounds.left)
                                    slider.children[0].style.left = `${Math.max(Math.min(percentX * 100, 99), 1)}%`
                                    if (slider.classList.contains("color-picker-hue")) {
                                        document.documentElement.style.setProperty('--saved-color-hue', `${Math.floor(percentX * 360)}deg`);
                                    }
                                    else if (slider.classList.contains("color-picker-saturation")) {
                                        document.documentElement.style.setProperty('--saved-color-saturation', `${Math.floor(percentX * 100)}%`);
                                    }
                                    else if (slider.classList.contains("color-picker-value")) {
                                        document.documentElement.style.setProperty('--saved-color-value', `${Math.floor(percentX * 100)}%`);
                                    }
                                    updateColor()
                                }
                                catch (e) {
                                    log(e)
                                }
                            })
                        }
                    </script>

                </div>
            </div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('backdrop');
        const ctx = canvas.getContext('2d');
        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        resize();

        const divisions = 25;
        const pointsX = width / divisions;
        const pointsY = height / divisions;
        const noiseScale = 25
        perlin.seed();

        let frameCount = 0;
        const draw = () => {
            ctx.clearRect(0, 0, width, height);
            for (let x = -10; x <= pointsX + 10; x++) {
                for (let y = -10; y <= pointsY + 10; y++) {
                    const time = Date.now();
                    const value = perlin.get((x + (time / 500) % 500) / noiseScale, (y + (time / 500) % 500) / noiseScale);
                    let colorValue = value * 2;
                    colorValue *= 50;

                    ctx.beginPath();
                    const newCircleX = x * divisions + colorValue * 0.5;
                    const newCircleY = y * divisions + colorValue * 2;
                    ctx.arc(newCircleX, newCircleY, value + 0.5 * 3, 0, Math.PI * 2);
                    let value255 = (value + 0.5) * 255;
                    value255 /= 1.5;
                    value255 += 30
                    ctx.fillStyle = `rgb(${value255}, ${value255}, ${value255})`;
                    ctx.fill();
                }
            }
            // Clear perlin memory every 30 frames to prevent memory leak
            frameCount++;
            if (frameCount % 30 === 0) {
                perlin.clearMemory();
            }
        }
        const drawInterval = setInterval(draw, 10);


    </script>
</body>

</html>