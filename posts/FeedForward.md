{
"title": "AI vs. Anti-cheats",
"description": "Implementing neural networks is a double-edged sword for anti-cheats.",
"tags": ["Anti-cheat", "AI", "C++"],
"author": "Strayfade",
"date": "7/22/2023",
"showTitle": true,
"indexed": true,
"pinned": true
}

### Introduction

> The source code for this project can be found at [Strayfade/FNN](https://github.com/Strayfade/FNN).

Are "neural anti-cheats" like Valve's "VACnet" the solution to cheating in video games? Possibly. However, just as neural networks can be used by anti-cheat to detect cheaters, cheaters can use neural networks to avoid anti-cheat.

This article will be discussing how certain input methods, such as mouse movement, can be easily detected by anti-cheat software and how this problem can be solved through the use of input randomization and "humanization" through neural networks.

First, let's look at the flagship up-and-coming neural network anti-cheat by Valve, VACnet.

<img src="/assets/images/FeedForward1.png"/>
<p class="image-caption">The presumed patent for Valve's neural-network-based anti-cheat, VACnet</p>

By looking at [Valve's patent](https://patentimages.storage.googleapis.com/e5/80/ee/aadc4e252c6791/WO2019182868A1.pdf) for VACnet, lots of information can be revealed about the upcoming anti-cheat's inner workings. On [page 44](https://patentimages.storage.googleapis.com/e5/80/ee/aadc4e252c6791/WO2019182868A1.pdf#page=44), Valve displays some of the values forwarded through the network to determine the likelihood that a player is cheating. Notable values are `pitch` and `yaw`, which likely represent the direction that an in-game player's camera is facing.

<img src="/assets/images/FeedForward2.png"/>
<p class="image-caption">Example inputs given to the VACnet neural network anti-cheat software.</p>

When looking at the ways that anti-cheat software can detect cheating, one of the primary detection vectors has always been mouse movement. As such, *many* different anomalies related to mouse movement can trigger an anti-cheat, including but not limited to:

 - Mouse events being sent directly by the mouse don't align with in-game movements.
 - Mouse movements are unpredictable and erratic.
 - The mouse cursor moves extremely quickly and at unrealistic speeds.
 - The mouse cursor is being moved by an external program instead of directly by input device.
 - A mouse movement event has a `LLMHF_INJECTED` flag set to show it did not originate from a valid input device.
 - *and more!*

After looking at some of these detection vectors, one thing is immediately obvious: some of the vectors are determined by the computer itself (such as the `LLMHF_INJECTED` flag), and others seem like "common-sense" (we can call these **heuristic**) vectors. An example of a heuristic detection vector would be the cursor's speed greatly changing or moving erratically.

### What measures can be taken to prevent these detections?

Actually, a surprising amount can be done to prevent anti-cheat detection regarding mouse movement.

For detection vectors that are created by the computer itself, it is possible to manipulate the mouse events using a kernel-mode driver. A good example of this is [vsaint1's **kernel-mouse** repository on GitHub](https://github.com/vsaint1/kernel-mouse), which demonstrates a way to spoof legitimate, valid mouse events using a kernel-mode driver on Windows. 

This prevents the `LLMHF_INJECTED` flag from being appended to mouse events (such as those created using `SendInput`). Some lower-level anti-cheats, such as Vanguard by Riot Games, will outright reject mouse input if it contains the flag, meaning that nothing will happen in-game when using `SendInput`. Fortunately, `SendInput` is a Windows API relied on by many pieces of legitimate software (such as macro and accessibility software), so mouse movement should still *work* in most games, even if it means getting flagged by anti-cheat.

### Heuristic vectors

Even if your movement source appears completely valid to a kernel-mode anti-cheat, the cursor's movements themselves might still trigger detections. If the cursor suddenly changes speed too quickly, moves at a constant speed, or moves at an exponentially decreasing speed (a sign of smoothing functions), then an advanced anti-cheat could still be triggered. 

Somewhat recently, players of Counter-Strike 2 learned that [by moving their cursor very quickly in-game, VACnet would be triggered](https://www.reddit.com/r/cs2/comments/17ea7wg/reproduceable_highdpi_vac_ban_bug/) and they would be banned from the server. This was likely due to VACnet being trained on many different types of hacks, including Spinbot, a notorious type of hack that moves the player's cursor at very high speeds.

Of course, the solution to many of these heuristic detection vectors is to have the mouse input generated by a neural network as well. Ideally, a network could be trained on a highly skilled player's cursor movements and recreate them in-game.

### Writing a neural network for input "humanization"

When looking for ways to "humanize" computer-generated mouse movements, I first wrote a C++ program to capture and graph my mouse cursor's speed over time. 

<img src="/assets/images/FeedForward3.png"/>
<p class="image-caption">The speed (Y) of my mouse cursor for various movement curves over time (X).</p>

The most important thing that this graph shows is that nearly every line follows an inverted-U curve. The mouse has inertia, meaning that it takes time to reach its full speed, and then takes time to slow down.

When comparing this to the most widely-used smoothing function, differences are obvious. 

> `<em>f(x) = (t - x) / c + x</em>`
> 
> **_x_** represents the current location of the cursor (X or Y) and **_t_** represents the target coordinate.

Using this smoothing function, the speed curve would constantly be linearly decreasing. This is easily detectable compared to the mouse cursor's natural speed.

<h3 style="text-align: center;">(this article is unlisted and a work-in-progress...)<h3>
<h3 style="text-align: center;">come back later!<h3>